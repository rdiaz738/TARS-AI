"""
module_engine.py

Core module for TARS-AI responsible for:
- Predicting user intents and determining required modules.
- Executing tool-specific functions like web searches and vision analysis.

This is achieved using a pre-trained Naive Bayes classifier and TF-IDF vectorizer.
"""

# === Standard Libraries ===
import os
import joblib
from datetime import datetime
import threading 

# === Custom Modules ===
from module_websearch import search_google, search_google_news
from module_vision import describe_camera_view
from module_nest import fetch_and_display_snapshot

# === Constants ===
MODEL_FILENAME = 'engine/pickles/naive_bayes_model.pkl'
VECTORIZER_FILENAME = 'engine/pickles/module_engine_model.pkl'

# === Load Models ===
try:
    if not os.path.exists(VECTORIZER_FILENAME):
        raise FileNotFoundError("Vectorizer file not found.")
    if not os.path.exists(MODEL_FILENAME):
        raise FileNotFoundError("Model file not found.")
    nb_classifier = joblib.load(MODEL_FILENAME)
    tfidf_vectorizer = joblib.load(VECTORIZER_FILENAME)

except FileNotFoundError as e:
    # Attempt to train models if files are missing
    import module_engineTrainer
    module_engineTrainer.train_text_classifier()
    try:
        nb_classifier = joblib.load(MODEL_FILENAME)
        tfidf_vectorizer = joblib.load(VECTORIZER_FILENAME)
    except Exception as retry_exception:
        raise RuntimeError("Critical error while loading models.") from retry_exception


# === Functions ===
def predict_class(user_input):
    """
    Predicts the class and its confidence score for a given user input.

    Parameters:
        user_input (str): The input text from the user.

    Returns:
        tuple: Predicted class and its probability score.
    """
    query_vector = tfidf_vectorizer.transform([user_input])
    predictions = nb_classifier.predict(query_vector)
    predicted_probabilities = nb_classifier.predict_proba(query_vector)

    predicted_class = predictions[0]
    max_probability = max(predicted_probabilities[0])

    # Return None if confidence is below threshold
    if max_probability < 0.75:
        return None, max_probability
    print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] TOOL: Using Tool {predicted_class} at {max_probability}")
    return predicted_class, max_probability


def check_for_module(user_input):
    """
    Determines the appropriate module to handle the user's input based on predictions.

    Parameters:
        user_input (str): The input text from the user.

    Returns:
        str: A response generated by the determined module or a default message if no module is needed.
    """
    predicted_class, probability = predict_class(user_input)

    if "search google" in user_input.lower():
        predicted_class = "Search"

    if predicted_class:
        if predicted_class == "Weather":
            weather_info = search_google(user_input)
            return f"*Using tool Web Search* Use the following results from a realtime web search: {weather_info}"

        elif predicted_class == "News":
            result = search_google_news(user_input)
            return f"*Using tool Web Search* Summarize the news from the following web search results: {result}"

        elif predicted_class == "Vision":
            result = describe_camera_view()
            return f"*Using tool Vision* The following is a summary of what TARS can see: {result}"

        elif predicted_class == "Search":
            result = search_google(user_input)
            return f"*Using tool Web Search* Use this answer from Google to respond to the user: {result}"

        elif predicted_class == "Goodbye":
            return "*User is leaving the chat politely*"

        elif predicted_class == "Chat":
            return "No_Tool"
        
        elif predicted_class == "Mute":
            return "Mute"
        elif predicted_class == "NestCamera":
            threading.Thread(target=fetch_and_display_snapshot, daemon=True).start()
            return "Displaying Nest camera feed."


    # Default response if no suitable module is found
    return "No_Tool"